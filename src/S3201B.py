#!/usr/bin/env python3
# -*- coding: utf-8


# Программа для чтения информации из файла pickle, взаимодействия с пользователем,
# поиска кратчайшего пути по графу и вывода результатов
from os.path import join, abspath
import pickle
from prettytable import PrettyTable
from S3201A import station_name


# Функция для запроса от пользователя номера линии и станции
def spros(nach_kon):
    templn = {}  # Создаем словарь для установления соответствия между порядковым номе
    myTable = PrettyTable(['№ линии', 'Название линии']) # Выводим список порядковых номеров и названий станций
    for (no, nl, lin_name), nr in zip(temp_lines, range(1, 100)): #сделали с помощью map порядклвые номера станций так как их id идут не по порядку
        templn[nr] = nl
        myTable.add_row([nr, lin_name])
    print(myTable)
        
    nline = int(input(f'\nВведите номер линии {nach_kon}ой станции: '))
    nline = templn[nline]
    print(f'Выбрана {nach_kon}ая линия: {lines[nline]["name"]}\n')
    
    tempst  = {}  # Создаем словарь для установления соответствия между порядковым номером, который будет вводить пользователь, и номером станции в нашей базе
    n = 0
    myTable = PrettyTable(['№ станции','Название станции','Id_st'])
    for sta in stations.values():
        if sta['line_id'] == nline:
            n += 1
            myTable.add_row([n, station_name(sta['id']), sta['id']])
            tempst[n] = sta['id']
    myTable.align['Название станции'] = 'l'
    print(myTable)
    
    nst = int(input(f'\nВведите номер {nach_kon}ой станции: '))
    nst1 = tempst[nst]
    return nst1


# Функция для поиска кратчайшего пути
def findminp(nst1, nst2):
    u, s, p = set(), {nst1: 0}, {}  # u - множество станций, итоговое время пути через которые минимально, p - словарь предков (посещенных вершин),
    # s - словарь с парами вершина:суммарное_время_пути_до_нее, записанными в ходе поиска кратчайшего пути
    while True:
        n, m = None, None # n - вершина, время пути до которое минимально, m - минимальное время пути до вершины n
        # Задаем значения None для обрабатываемой на данной итерации вершины и минимального расстояния до
        for x in s: # Перебираем все вершины из словаря следующих вершин s (до которых знаем путь)
            if x not in u: # При этом перебираем только вновь добавленные возможные станции, и не перебираем уже обработанные, находящиеся в множестве u
                if n == None: # Если это первая вершина, которую обрабатываем на данной итерации,
                # разбираем пару id_станции : время_пути_до_нее на две переменные n и m
                    n, m = x, s[x]
                else: # Если это уже не первая вершина, которую обрабатываем на данной итерации,
                # сравниваем время пути до нее с минимальным временем пути для данной итерации (значение переменной m)
                    if s[x] < m:  # Если время пути до текущей обрабатываемой вершины меньше находящегося в переменной m, обновляем значения n и m
                        n, m = x, s[x]
        if n == None: # Если на предыдущей итерации новых станций в словарь s не добавлено, значит станция назначения недостижима
            return None
        if n == nst2: # Если достигли станцию назначения
            result = [nst2]
            x = nst2
            while x != nst1: # Проходим по словарю p, пока не дойдем до начальной станции, и добавляем в список result все станции,
            # через которые прошли для достижения конечной станции
                x = p[x]
                result.append(x) # Разворачиваем список, чтобы пройденные станции шли в прямом направлении (от станции отправления до станции назначения), а не в обратном
            return result, s[nst2] # Возвращаем список пройденных станций (путь через которые минимален) и суммарное время пути до станции назначения
        u.add(n) # Добавляем в множество u номер станции, время пути до которой минимально
        for x in gr[n]:  # Проверяем по графу, к каким станциям x можем отправиться с вновь добавленной в множество u станции n
            try: # Т.к. в словаре gr имеем кроме числовых пар id_станции: время_движения_до_нее (куда можно отправиться с текущей станции)
            # еще и пару "name": "Название_станции_(Название_линии)", выделяем только числовые ключи
                _ = int(x)
            except ValueError: # Если попался текстовый ключ - переходим к следующему ключу
                continue
            if x not in u: # Если станции х, к которой можно переместиться с текущей станции n, нет в множестве u
                if x not in s: # Если станции х, к которой можно переместиться с текущей станции n, нет в словаре s
                    s [x], p[x] = gr[n][x] + m, n # Добавляем в словарь s пару s[x]:gr[n][x] + m (следующая возможная станция : суммарное время пути до нее с учетом уже пройденного)
                    # Добавляем в словарь p пару p[x]:n (текущая_станция : предыдущая_станция)
                else: # Если станция х, к которой можно переместиться с текущей станции n, уже есть в словаре s
                    if s[x] > gr[n][x] +m:  # Если суммарное время пути до станции x (уже записанное в словаре s для станции х) больше,
                    # чем время пути до этой же станции через станцию n, обновляем значение времени для ключа x в словаре s
                        s [x], p[x] = gr[n][x] + m, n
    

data_path = abspath(join('..', 'Data', 'scheme.pickle')) # Восстанавливаем данные, сохраненные модулем pickle

with open(data_path, mode='rb') as dst:
    gr = pickle.load(dst)
    lines = pickle.load(dst)
    stations = pickle.load(dst)
print(f'Все данные из {data_path} по станциям и линиям восстановлены.')

temp_lines = [(x["ordering"], x["id"], x["name"]) for x in lines.values()]
temp_lines.sort()

# Организация диалога с пользователем
nst1 = spros('начальн')
nst2 = spros('конечн')

print(f'\nВыбрана начальная станция {station_name(nst1)} {nst1}')
print(f'Выбрана конечная станция {station_name(nst2)} {nst2}')

print(f'Ищем минимальный путь между {nst1} и {nst2}') # Поиск кратчайшего пути между станциями отправления и назначения
nst1, nst2 = nst2, nst1
res = findminp(nst1, nst2)

if res:
    myTable = PrettyTable(['Время', 'Название станции', 'Id_st'])
    mpas, minp = res # mpas - список станций из result, minp - суммарное время пути до станции назначения
    xold = None
    tx = 0
    for x in mpas: # Формируем время следования от предудущей к следующей станции нарастающим итогом
        if xold:
            tx += gr[xold][x]
        else:
            tx = 0
        myTable.add_row([
            f'{tx//3600:02d}:{(tx%3600)//60:02d}:{tx%60:02d}',
            f'Станция {station_name(x)}',
            f'({x})'
        ])
        xold = x
    myTable.align['Название станции'] = 'r'
    print(myTable)
    print(
        f'\nОбщее время пути: {minp//3600:02d} час. '
        f'{(minp%3600)//60:02d} мин. и {minp%60:02d} сек.'
        )
else:
    print('Путь между станциями не найден')
